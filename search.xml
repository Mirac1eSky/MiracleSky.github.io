<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>吴恩达深度学习系列SCW1</title>
      <link href="/posts/1ca99e0.html"/>
      <url>/posts/1ca99e0.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="/js/baidu.js"></script><script type="text/javascript" src="/js/360.js"></script><h1 id="【吴恩达深度学习系列第二课第一周笔记】"><a href="#【吴恩达深度学习系列第二课第一周笔记】" class="headerlink" title="【吴恩达深度学习系列第二课第一周笔记】"></a>【吴恩达深度学习系列第二课第一周笔记】</h1><p>现在开始记录第二课程的笔记。会慢慢更新的。</p><a id="more"></a><h2 id="正确设置训练集，验证集（开发集）测试集"><a href="#正确设置训练集，验证集（开发集）测试集" class="headerlink" title="正确设置训练集，验证集（开发集）测试集"></a>正确设置训练集，验证集（开发集）测试集</h2><p>在机器学习小数据量时代即当你的数据集在100,1000,10000的时候，可以采用60%：20%：20%的比例来，即用60%的数据来训练模型，20%的数据来评估不同你不同的模型，最后用20%的数据集来评估选定模型的性能。</p><p>但是当数量达到百万级别时，我们就可能不在需要这么高的比例来划分出验证集。因为验证集的目的就是用来快速验证不同的算法之间的差别，所以可能不再不要这么多的数据作为验证集。举个例子，当我们有一百万的数据时，可能只需要一万条数据来验证就行了。同样的，最后的测试集也是如此。所以最终的比例就是98%：1%：1%。对于数据量过百万的情况，可能就是99.5%：0.25%：0.25%.</p><h2 id="训练集和测试集分布不匹配"><a href="#训练集和测试集分布不匹配" class="headerlink" title="训练集和测试集分布不匹配"></a>训练集和测试集分布不匹配</h2><p>比如说你有个应用，通过用户上传图片，然后告诉用户这张图片是不是猫咪。相比较而言，你的训练集都是从网上下载下来的高分辨率图片，并且构图精巧。而用户上传的图片可能分辨率就不是很高，并且更加随意。这个时候你的训练集和测试集的分布就不一样了。对此，吴老师的建议是确保分布相同，具体会在后面的课程提到。</p><h2 id="偏差和方差以及偏差方差权衡"><a href="#偏差和方差以及偏差方差权衡" class="headerlink" title="偏差和方差以及偏差方差权衡"></a>偏差和方差以及偏差方差权衡</h2><p>对于偏差和方差问题应该都会有大致了解了。比如高偏差对应欠拟合，高方差对应了过拟合。如图所示：</p><p><img src="https://i.loli.net/2020/04/16/s7D4uXlU5OikgQB.png" style="zoom:50%;"></p><p>接下来看看如何分析偏差和方差：</p><p>假设你有个识别猫咪的分类器，得到了不同的误差集合：</p><p><img src="https://i.loli.net/2020/04/16/dyigBtOIGLu3nzc.png" alt></p><ol><li><p>当训练集误差是第一列时，可以看到在训练集上误差很小，但是在验证集上误差很大，说明过拟合了。</p></li><li><p>当训练集为第二列时，可以看到在训练集和验证集上的表现都不是很好，说明该模型在训练集是欠拟合，而在验证集上表现也符合该预测</p></li><li>当训练集为第三列时，训练集和验证集的表现都不行，并且验证集的表现比训练集差很多。说明该模型不仅存在高偏差的问题，并且还存在高方差的问题。也就是说该分类器在总体上是欠拟合的，但是在部分数据上又表现出过拟合的问题。</li><li>第四列则是开发人员很希望看到的，就是在训练集和验证集上的误差都很小，说明是适拟合的情况。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>力扣每日一题</title>
      <link href="/posts/206c9e3b.html"/>
      <url>/posts/206c9e3b.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="/js/baidu.js"></script><script type="text/javascript" src="/js/360.js"></script><h1 id="力扣每日一题（力扣官网）"><a href="#力扣每日一题（力扣官网）" class="headerlink" title="力扣每日一题（力扣官网）"></a>力扣每日一题（<a href="https://leetcode-cn.com/" target="_blank" rel="external nofollow noopener noreferrer">力扣官网</a>）</h1><p>今天开始 记录力扣上刷的题目，目的就是防止偷懒。。。做题顺序的话是看那道题目不顺眼，就先把那道题目做了！若无特殊声明，所有代码语言都是python3。下面直接开始做题。</p><a id="more"></a><h2 id="1-数字-n-代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且-有效的-括号组合"><a href="#1-数字-n-代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且-有效的-括号组合" class="headerlink" title="1.数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合"></a>1.数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合</h2><p>看到这道题 第一反应就是暴力法，直接列出所有可能性，然后判断是否正确就行了。但是觉得这样不是很好就没有去实现，实际操作应该是可行的。除了暴力法，还能想到什么办法呢，答案就是二叉树。因为括号分左右，而二叉树正好有左子树和右子树，所以这题其实就是搜索二叉树符合条件的节点。然后分析一下这可二叉树有什么特点：</p><ul><li>二叉树的根节点一定是  “(“，因为如果是右括号就没有正确答案了</li><li>在左括号有剩余的情况下，就可以生成左节点，最多添加n个</li><li>插入右括号的前提是 左括号的个数大于右括号（这里说的是生成节点上的，而不是剩余的括号个数）</li></ul><p>可以画个草图看一下：</p><p><img src="https://i.loli.net/2020/04/09/wCIGu9KPV5JFtO1.png" alt></p><p>红括号中就是显然错误的分支，没有必要继续往下遍历，也就是插入右括号时没有满足 第三个特点。</p><p>而黑色括号括起来的就是正确的结点。图中没有画出所有的结点。有兴趣的可以自己画画。</p><p>接下来就直接来实现代码：</p><p>首先。需要左括号，右括号的个数，然后一个result保存最终结果，tmp保存路径，也就是到达哪个节点。接下来然后直接深度遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def generateParenthesis(self, n):</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        self.dfs(res, n, n, &#39;&#39;)</span><br><span class="line">        return res</span><br><span class="line">        </span><br><span class="line">    def dfs(self, res, left, right, tmp):</span><br><span class="line">        if left &#x3D;&#x3D; 0 and right &#x3D;&#x3D; 0:</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            return</span><br><span class="line">        if left &gt; 0:</span><br><span class="line">            self.dfs(res, left - 1, right, tmp + &#39;(&#39;)</span><br><span class="line">        if left &lt; right:</span><br><span class="line">            self.dfs(res, left, right - 1, tmp + &#39;)&#39;)</span><br></pre></td></tr></table></figure><hr><h2 id="2-给定一个字符串，逐个翻转字符串中的每个单词。"><a href="#2-给定一个字符串，逐个翻转字符串中的每个单词。" class="headerlink" title="2.给定一个字符串，逐个翻转字符串中的每个单词。"></a>2.给定一个字符串，逐个翻转字符串中的每个单词。</h2><p>这道题目怎么讲呢，如果调用api的话就很简单，利用split和reverse函数，可以直接得到结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def reverseWords(self, s: str) -&gt; str:</span><br><span class="line">return &quot; &quot;.join(reversed(s.split()))</span><br></pre></td></tr></table></figure><p>如果不用reversed，split，join这几个函数，要怎么实现呢？ 其实我一贯秉承能偷懒就绝不多动一下的理念，哈哈，所以就直接用最笨的方法吧。首先对于一个字符串，我们要将他分割为一个一个的单词，最后反向输出得到最终结果。大致思路就是这样，然后我们需要考虑一下异常情况，就是 字符串 首部出现空格，中间出现多个空格的情况做处理，也就是下面几种情况：</p><ol><li><p>首先处理首部的字符串，确保第一个字符不为空格，如果为空格，则去除</p></li><li><p>用两个指针，来循环字符串，因为我们需要判断什么时候将字符组成一个字符串，而字符串中间出现的空格符就是标志</p></li><li><p>两个指针的另一个目的在于，当两个单词之间，出现多个空格时，单指针无法判断，我们需要双指针来判断：</p><ul><li>当左指针不为空，右指针不为空，说明这个单词还没结束</li><li>当左指针不为空，右指针为空时，确定前面的字符组成一个单词</li><li>当左指针为空，右指针为空时，说明处在中间的空白符，继续向下遍历</li><li>当左指针为空，右指针不为空时，说明开始处理下一个单词</li></ul></li><li><p>最后得到一个数组，里面按顺序放好单词，只要反向遍历数组，就能得到结果</p></li></ol><p>直接上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">def reverseWords1(s):</span><br><span class="line">while True:</span><br><span class="line"># 去除头空格</span><br><span class="line">if len(s) &#x3D;&#x3D; 0:</span><br><span class="line">return &quot;&quot;</span><br><span class="line">if s[0] &#x3D;&#x3D; &#39; &#39;:</span><br><span class="line">s &#x3D; s[1:]</span><br><span class="line">continue</span><br><span class="line">else:</span><br><span class="line">break</span><br><span class="line">p,q &#x3D; 0,1</span><br><span class="line">length &#x3D; len(s)</span><br><span class="line">word  &#x3D; &#39;&#39;</span><br><span class="line">words &#x3D; []</span><br><span class="line">while True:</span><br><span class="line">##当指针到达字符串末尾时，结束循环，并将最后一个单词加入，如果是空白字符串，就不加入</span><br><span class="line">if q &#x3D;&#x3D; length - 1:</span><br><span class="line">if s[p] !&#x3D; &#39; &#39; :</span><br><span class="line">word &#x3D; word + s[p]</span><br><span class="line">if s[q] !&#x3D; &#39; &#39;:</span><br><span class="line">word &#x3D; word + s[q]</span><br><span class="line">if word &#x3D;&#x3D; &#39;&#39; or word &#x3D;&#x3D; &#39; &#39;:</span><br><span class="line">break</span><br><span class="line"></span><br><span class="line">words.append(word)</span><br><span class="line">break</span><br><span class="line"></span><br><span class="line">if q &gt; length - 1:</span><br><span class="line">if s[p] !&#x3D; &#39; &#39;:</span><br><span class="line">word &#x3D; word + s[p]</span><br><span class="line">if word &#x3D;&#x3D; &quot;&quot; or word &#x3D;&#x3D; &#39; &#39;:</span><br><span class="line">break</span><br><span class="line">words.append(word)</span><br><span class="line">break</span><br><span class="line"></span><br><span class="line">if s[p] !&#x3D; &#39; &#39; and s[q] !&#x3D; &#39; &#39;:</span><br><span class="line">word &#x3D; word + s[p]</span><br><span class="line">word &#x3D; word + s[q]</span><br><span class="line">p &#x3D; p + 2</span><br><span class="line">q &#x3D; q + 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elif s[p] !&#x3D; &#39; &#39; and s[q] &#x3D;&#x3D; &#39; &#39;:</span><br><span class="line">word &#x3D; word + s[p]</span><br><span class="line">words.append(word)</span><br><span class="line">word &#x3D; &#39;&#39;</span><br><span class="line">p &#x3D; p + 2</span><br><span class="line">q &#x3D; q + 2</span><br><span class="line"></span><br><span class="line">elif s[p] &#x3D;&#x3D; &#39; &#39; and s[q] !&#x3D; &#39; &#39;:</span><br><span class="line"></span><br><span class="line">words.append(word)</span><br><span class="line">word &#x3D; &#39;&#39;</span><br><span class="line">p &#x3D; p + 1</span><br><span class="line">q &#x3D; q + 1</span><br><span class="line"></span><br><span class="line">elif s[p] &#x3D;&#x3D; &#39; &#39; and s[q] &#x3D;&#x3D; &#39; &#39;:</span><br><span class="line"></span><br><span class="line">p &#x3D; p + 2</span><br><span class="line">q &#x3D; q + 2</span><br><span class="line"></span><br><span class="line">length &#x3D; len(words) - 1</span><br><span class="line">s &#x3D; &#39;&#39;</span><br><span class="line">while length &gt; -1:</span><br><span class="line">if words[length] &#x3D;&#x3D; &#39;&#39;:</span><br><span class="line">length &#x3D; length - 1</span><br><span class="line">continue</span><br><span class="line">s &#x3D; s + words[length] + &#39; &#39;</span><br><span class="line">length &#x3D; length - 1</span><br><span class="line"></span><br><span class="line">length &#x3D; len(s)</span><br><span class="line">s &#x3D; s[:length-1]</span><br><span class="line">return s</span><br></pre></td></tr></table></figure><p>这个代码写的很粗糙，因为只是简单实现这种思路，仅供借鉴，当不得真~</p><hr><h2 id="3-鸡蛋掉落"><a href="#3-鸡蛋掉落" class="headerlink" title="3.鸡蛋掉落"></a>3.鸡蛋掉落</h2><p>这道题目是这样的，假设你有N个蛋，这个蛋从某层楼扔下来不会碎，一旦超过这一层，就会碎，而楼共有K层，问最少扔多少次，可以找出这个临界层？</p><p>先分下一下，这里所说的最少扔多少次的意思，其实就是在最坏情况下，要扔多少次。考虑清楚这个，我们来分析一下题目。其实刚看到这个题目，第一反应就是二分法这样每次可以缩减一半的范围。然后我们现在来从最简答的情况开始分析：</p><ol><li>N=1,K=100。也就是在这人只有一个蛋，楼层100层的情况。这种情况下显然最少要扔100次，才能确定，因为只有一个蛋，所以只能从1层开始扔，如果第一层就碎了，说明临界层为1，若是第二层碎，说明临界层为2……直到100层，所以最少次数需要100次，才能找出</li><li>N=<script type="math/tex">\infty</script>,K=100。这种情况下就可以用刚才说到的二分法，我们可以直接在50层扔，如果碎了，说明临界层在0-50，如果没有碎，说明在50-100层。然后在取中间数，直到不可以再分。显然这种情况下，可以得到一个公式<script type="math/tex">2^{M}\ge100</script>,也就是<script type="math/tex">M\ge \log_2100</script>,取个整数，也就是M=7</li></ol><p>下面看稍微复杂的一些情况：</p><ol><li><p>N=2，K=100。现在你有两个蛋，该如何确定临界层呢？虽然二分法不能用了，但是我们可以借鉴思路。一共有两个蛋，那么我们用第一个蛋来确定范围，我们将100 划分为0-10,10-20……这样的间隔。我们用第一个蛋在第10层，20层……100层的地方按顺序扔，如果他在某一层碎了，那么就可以用第二个蛋在刚刚的区间中来具体确定。比如说在第十层楼扔的时候碎了，那么再用第二个蛋从第一层一直扔到第九层，那么一共就需要十次。假设在第100层的时候才碎，那么从第91扔到99，又扔了9次，加上第一个蛋用来确定范围扔了十次，那么一共就是19次。这样就得到找出临界层的最少次数。我们来思考一下，虽然得到了最少次数，但是这个值是分布在10~19之间的，有没有办法让这个值更均匀一点？</p><p>首先看到造成这个值的范围的原因是因为在分间隔的时候，是等间距分的，这就造成了当第一个鸡蛋扔的范围越大时，由于第二个鸡蛋要具体确定的楼层扔的次数都为9，所以值就是这样一个范围。那么现在我们将这个间隔不均匀分布，来看看是什么情况。</p></li><li><p>依旧是 N=2，K=100。这次这样来分，第一个区域为n，第二个区域为n-1，直到最有一个区域为1，这样的话，第一个鸡蛋每确定一个区域，第二个鸡蛋所需要检验的次数也会减1。这样总次数应该会平均一些。我们来计算一下。首先确定n的值，也就是</p><script type="math/tex; mode=display">1 + 2 +3 +...+n = \frac{n(n+1)}{2} \ge 100</script><p>这样n取整数为14，这样我们将100就划分为 14,  27，39，50，60,  69，77， 84， 90， 95， 99， 100。因为是取整数，所以最后不是继续加3，而是加1。那么一共分为12个区域，也就是说第一个鸡蛋最多扔十二次。如果第一个鸡蛋在14层碎了，那么需要用第二个鸡蛋来检验第1-13层，加上第一个鸡蛋扔的一次，就是14次，如果在27层碎了，那就要检验15-26层一共12层，加上第一个鸡蛋扔的两次一共14次。。。如果说第一个鸡蛋一直扔到最后一块区域才碎，那么第二个鸡蛋就不需要检验了，因为最后一个区域就一层楼，所以需要12次。也就是说按这种方式，至少需要扔14次就可以找出临界层。的确次数要比刚才的少。</p></li></ol><p>其实说到现在，我们只是解决了有两个蛋的情况，下面来看看更加复杂的情况，也就是楼层和鸡蛋都不确定的情况</p><p>假设楼层为K层，鸡蛋有N个，找出临界层所需要的最少次数为M。其实要找出来的就是M关于K，N的函数，假定这个函数为<strong>M（K,N）</strong>。我们可以先整个表格看一下(列为楼层，行为鸡蛋个数)。</p><div class="table-container"><table><thead><tr><th style="text-align:center">K\N</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>1</td><td>1</td><td>1</td></tr><tr><td style="text-align:center">2</td><td>2</td><td></td><td></td></tr><tr><td style="text-align:center">3</td><td>3</td><td></td></tr></tbody></table></div><p>   可以看到，当楼层为1或者鸡蛋个数为时，表格非常好填。但是当其都大于1时，就需要思考一下了。</p><p>需要考虑的是，第一个鸡蛋扔在哪里，其实我们也不清楚，假设第一个鸡蛋扔在了第h层，那么就得到了两种结果，一种是碎了，一种是没碎。    如果碎了，说明临界层在0-H层，如果没有碎，说明在H-K层之间。那么第一种情况下，还需要扔多少次呢，这个时候其实还是相同的问题，只是楼层和鸡蛋个数的变化，即次数为M(H-1,N-1)，如果是第二种情况，那么就是M(K-H,N)。其实到这里也都看出来是个递归问题。那么因为我们需要的是最坏的情况下的次数，所以取两种情况的最大值，加上第一次扔，所以有，在你第一层鸡蛋扔在第H层情况下所需要的总次数<script type="math/tex">M_H</script>，它就等于</p><script type="math/tex; mode=display">M_H = max\{M(H-1,N-1), M(K-H,N)\} + 1</script><p> 那么如何确定H呢，显然就是枚举，H取值范围1~K，即我们有<script type="math/tex">M_1,M_2,....M_k</script>，我们的需要的是这个里面的最小值，所以就是说总次数M，就等于</p><script type="math/tex; mode=display">M = min\{M_1,M_2,M_3...M_K \}</script><p>这样的话，终于算出了最终结果，其实还是挺复杂的一个问题，接下来我们就直接用代码实现吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def throwEgg(K,N):</span><br><span class="line">#若楼高K为1，则一次</span><br><span class="line">if K &#x3D;&#x3D; 1:</span><br><span class="line">return 1</span><br><span class="line">#创建 K+1 行 N+1列的数组(注意这里生成数组 不能使用[[0] * (N + 1)]*(K + 1)</span><br><span class="line">#因为这样生成的数组，只是生成了k+1个引用，当修改值时会一起修改从而导致bug</span><br><span class="line">res &#x3D; [[0] * (N + 1) for _ in range(K + 1)]</span><br><span class="line">#如果 只有一个鸡蛋，那么次数就为楼高</span><br><span class="line">for i in range(1,N+1):</span><br><span class="line">res[1][i] &#x3D; 1</span><br><span class="line">m &#x3D; -1</span><br><span class="line">#遍历所有楼层的情况</span><br><span class="line">for i in range(2,K+1):</span><br><span class="line">#在指定楼层，遍历所有鸡蛋的情况，这里是通过最基本的情况，去求解复杂的情况</span><br><span class="line">for j in range(1, N + 1):</span><br><span class="line">res[i][j] &#x3D; 1 + res[i - 1][j - 1] + res[i - 1][j]</span><br><span class="line">if res[i][N] &gt;&#x3D; K:</span><br><span class="line">m &#x3D; i</span><br><span class="line">break</span><br><span class="line">return m</span><br></pre></td></tr></table></figure><p>这道题目写起来挺麻烦，并且这里没有使用递归求解，感觉递归会更麻烦。这道题其实还有更多的解法，这里不展示了，有空在继续更新。</p><hr><h2 id="4-交点"><a href="#4-交点" class="headerlink" title="4.交点"></a>4.交点</h2><p>题目描述：给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。</p><p>乍一看我还觉得这道题目挺简单的。后来发现题目要求是线段而不是直线。。。然后发现这道题巨烦，倒不是多难，而是要讨论的情况太多。下面来具体看看有那些情况：</p><ol><li><p>当两条线段为铅垂线时，先讨论两条直线的横坐标，若不同，则没交点，如果相同，在讨论两条线段的位置关系：先判断线段哪条的最高点更高，然后在具体讨论位置关系：</p><ul><li><p>两条铅垂线平行，即无交点</p></li><li><p>两条铅垂线在一条直线上，首先要判断是否重合。这样先取两条线段中的左右端点。然后判断两条线段在纵轴上谁更”高”一点。在比较以后，将较高的那条线段叫第一条线FL,较低的那个端点为（fminx，fminy）,较高的那点记做（fmaxx，fmaxy）剩余的那条叫SL，较低的那个端点为（sminx，sminy）,较高的那点记做（smaxx，smaxy）。然后在分情况讨论：</p><ul><li>当fminy &gt; smax的时候，两线段无交点。</li><li>当fminy &lt;= smax的时候，线段相交，然后需要讨论fminy与sminy的关系：<ol><li>fminy &lt; = sminy,说明FL包含了SL，那么按题目要求交点即为(sminx,sminy)</li><li>fminy &gt; sminy,说明FL与SL相交，那么按题目要求交点即为(sminx,fminy)</li></ol></li></ul><p><img src="https://i.loli.net/2020/04/13/MOgbl2JqFDVYBTy.png" alt></p></li></ul></li><li><p>当两条线段为水平线时，先讨论两条直线的纵坐标，若不同，则没交点，如果相同，在讨论两条线段的位置关系：先判断线段哪条在坐标轴上更靠右，将较右的那条线段叫第一条线FL,较左边的那个端点为（fminx，fminy）,较右边的那点记做（fmaxx，fmaxy）剩余的那条叫SL，较左的那个端点为（sminx，sminy）,较右的那点记做（smaxx，smaxy）然后在具体讨论位置关系：</p><ul><li><p>两条水平线平行，即无交点</p></li><li><p>两条水平线在一直线上，然后继续分情况讨论：</p><ul><li>当fminx &gt; smaxx，无交点</li><li>当fminx &lt;= smaxx,线段相交，然后讨论fminx与sminx的关系：<ol><li>fminx &lt;= sminx,说明FL包含了SL，那么按题目要求交点即为(sminx,sminy)</li><li>fminx &gt; sminx, 说明FL与SL相交，那么按题目要求交点即为(fminx,fminy)</li></ol></li></ul><p><img src="https://i.loli.net/2020/04/13/NtdlKocbFOZLA2p.png" alt></p></li></ul></li><li><p>当斜率相同即平行时，若截距不同，则无交点，若截距相同，则在具体讨论位置关系，依旧将线段分为FL,SL，端点依旧是大的设为max，小的叫min</p><ul><li><p>当fminx &gt; smax 的时候，无交点</p></li><li><p>fminx &lt;= smax 时：</p><ul><li>fminx &lt;= sminx，交点就为(sminx,sminy)</li><li>fminx &gt; sminx, 交点就为(fminx,fminy)</li></ul><p><img src="https://i.loli.net/2020/04/13/uR4M9fzYSI5FtKi.png" alt></p></li></ul></li><li><p>当其中一条为铅垂线，一条为水平线的时候：</p><ul><li><p>当水平线的纵坐标 小于铅垂线的最小纵坐标 或者大于最大纵坐标，肯定无交点</p></li><li><p>当水平线的纵坐标在铅垂线的大小纵坐标之间的时候，如果水平线的左端点小于等于铅垂线的横坐标，右端点大于等于铅垂线的横坐标，则存在交点（铅垂线横坐标，水平线的纵坐标）</p><p><img src="https://i.loli.net/2020/04/13/R73ycL8sg2qN9If.png" alt></p></li></ul></li><li><p>最常见的情况，即斜率没什么规律的情况下，这个时候可以直接算出交点，利用简单的数学知识，可以推导出交点 x = (b2 - b1) / (k1 - k2)（b1，b2为两条直线的截距），然后用代入直线算出纵坐标y。之后就是讨论这个交点是否在两条线段之间，即是否在两条线段围出来的图形中。我采用交点到过两端点铅垂线的距离之和是否等于端点距离之和，如果等于说明在范围内，即交点有效，否则无效。</p><p><img src="https://i.loli.net/2020/04/13/MRH6CvsVBlTKLOr.png" style="zoom:50%;"></p></li></ol><p>如图所示，红黑两条线段相交，分别判断交点到左右两条黄线和上下两条黄线的距离之和 是否直接等于端点的距离。</p><p>逻辑分下完了，下面可以写代码了，我这里的代码其实还可以精简，但是目前还没做，仅供参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">def judge(x1,y1,x2,y2,x1_1,y1_1,x2_1,y2_1,x,y):</span><br><span class="line">    # if x1 &lt;&#x3D; x &lt;&#x3D; x2 and x1_1 &lt;&#x3D; x &lt;&#x3D; x2_1 and y1 &lt;&#x3D; y &lt;&#x3D; y2 and y2_1 &lt;&#x3D; y &lt;&#x3D; y1_1:</span><br><span class="line">    #     return (x,y)</span><br><span class="line">    xdis1 &#x3D; abs(x1-x2)</span><br><span class="line">    ydis1 &#x3D; abs(y1-y2)</span><br><span class="line">    xtox1 &#x3D; abs(x1-x)</span><br><span class="line">    xtox2 &#x3D; abs(x-x2)</span><br><span class="line">    ytoy1 &#x3D; abs(y1-y)</span><br><span class="line">    ytoy2 &#x3D; abs(y-y2)</span><br><span class="line">    xdis2 &#x3D; abs(x1_1-x2_1)</span><br><span class="line">    ydis2 &#x3D; abs(y1_1-y2_1)</span><br><span class="line">    xtox1_1 &#x3D; abs(x - x1_1)</span><br><span class="line">    xtox2_1 &#x3D; abs(x - x2_1)</span><br><span class="line">    ytoy1_1 &#x3D; abs(y - y1_1)</span><br><span class="line">    ytoy2_1 &#x3D; abs(y - y2_1)</span><br><span class="line">    if xdis1 &#x3D;&#x3D; (xtox1 + xtox2) and ydis1 &#x3D;&#x3D; (ytoy1 + ytoy2) \</span><br><span class="line">        and xdis2 &#x3D;&#x3D; (xtox1_1 + xtox2_1) and ydis2 &#x3D;&#x3D; (ytoy1_1 + ytoy2_1):</span><br><span class="line">        return (x,y)</span><br><span class="line">    else:</span><br><span class="line">        return []</span><br><span class="line">class Solution:</span><br><span class="line">    def intersection(self, start1: List[int], end1: List[int], start2: List[int], end2: List[int]) -&gt; List[float]:</span><br><span class="line">        </span><br><span class="line">        # 第一条直线</span><br><span class="line">        y1 &#x3D; start1.pop()</span><br><span class="line">        x1 &#x3D; start1.pop()</span><br><span class="line">        y2 &#x3D; end1.pop()</span><br><span class="line">        x2 &#x3D; end1.pop()</span><br><span class="line">        # 第二条直线</span><br><span class="line">        y1_1 &#x3D; start2.pop()</span><br><span class="line">        x1_1 &#x3D; start2.pop()</span><br><span class="line">        y2_1 &#x3D; end2.pop()</span><br><span class="line">        x2_1 &#x3D; end2.pop()</span><br><span class="line"></span><br><span class="line">        if x1 &#x3D;&#x3D; x2:</span><br><span class="line">            Y1 &#x3D; x1</span><br><span class="line">            k1 &#x3D; float(&#39;inf&#39;)</span><br><span class="line">        elif y1 &#x3D;&#x3D; y2:</span><br><span class="line">            Y1 &#x3D; y1</span><br><span class="line">            k1 &#x3D; 0</span><br><span class="line">        else:</span><br><span class="line">            k1 &#x3D; (y2 - y1) &#x2F; (x2 - x1)</span><br><span class="line">        if x1_1 &#x3D;&#x3D; x2_1:</span><br><span class="line">            Y1_1 &#x3D; x1_1</span><br><span class="line">            k2 &#x3D; float(&#39;inf&#39;)</span><br><span class="line">        elif y1_1 &#x3D;&#x3D; y2_1:</span><br><span class="line">            Y1_1 &#x3D; y1_1</span><br><span class="line">            k2 &#x3D; 0</span><br><span class="line">        else:</span><br><span class="line">            k2 &#x3D; (y2_1 - y1_1) &#x2F; (x2_1 - x1_1)</span><br><span class="line">        b1 &#x3D; -k1*x1 + y1</span><br><span class="line">        b2 &#x3D; -k2*x1_1 + y1_1</span><br><span class="line">        if k1 &#x3D;&#x3D; k2:</span><br><span class="line">            ##两条 铅锤线</span><br><span class="line">            if k1 &#x3D;&#x3D; float(&#39;inf&#39;):</span><br><span class="line">                ##相互平行</span><br><span class="line">                if x1 !&#x3D; x1_1:</span><br><span class="line">                    return []</span><br><span class="line">                else:</span><br><span class="line">                ##判断 两条铅锤线是否有交点</span><br><span class="line">                    fminy &#x3D; min(y1,y2)</span><br><span class="line">                    fmaxy &#x3D; max(y1,y2)</span><br><span class="line">                    sminy &#x3D; min(y1_1,y2_1)</span><br><span class="line">                    smaxy &#x3D; max(y1_1,y2_1)</span><br><span class="line">                ## 判断两条线谁高一点</span><br><span class="line">                    if fmaxy &gt;&#x3D; smaxy:</span><br><span class="line">                        if fminy &gt; smaxy:</span><br><span class="line">                            return []</span><br><span class="line">                        else:</span><br><span class="line">                            return (x1,fminy)</span><br><span class="line">                    else:</span><br><span class="line">                        if sminy &gt; fmaxy:</span><br><span class="line">                            return []</span><br><span class="line">                        else:</span><br><span class="line">                            return (x1,sminy)</span><br><span class="line">            ##两条 水平线</span><br><span class="line">            elif k1 &#x3D;&#x3D; 0:</span><br><span class="line">                ##相互平行</span><br><span class="line">                if y1 !&#x3D; y1_1:</span><br><span class="line">                    return []</span><br><span class="line">                else:</span><br><span class="line">                    ##判断 两条水平线是否有交点</span><br><span class="line">                    fminx &#x3D; min(x1,x2)</span><br><span class="line">                    fmaxx &#x3D; max(x1,x2)</span><br><span class="line">                    sminx &#x3D; min(x1_1,x2_1)</span><br><span class="line">                    smaxx &#x3D; max(x1_1,x2_1)</span><br><span class="line">                    ##判断哪条长一点</span><br><span class="line">                    if fmaxx &gt;&#x3D; smaxx:</span><br><span class="line">                        if fminx &gt; smaxx:</span><br><span class="line">                            return []</span><br><span class="line">                        else:</span><br><span class="line">                            return (fminx,y1)</span><br><span class="line">                    else:</span><br><span class="line">                        if sminx &gt; fmaxx:</span><br><span class="line">                            return []</span><br><span class="line">                        else:</span><br><span class="line">                            return (sminx,y1)</span><br><span class="line"></span><br><span class="line">                    # if fmaxx &lt; sminx or fminx &gt; smaxx:</span><br><span class="line">                    #     return []</span><br><span class="line">                    # if fmaxx &gt;&#x3D; sminx:</span><br><span class="line">                    #     return (fmaxx,y1)</span><br><span class="line">                    # if fminx &lt;&#x3D; smaxx:</span><br><span class="line">                    #     return (x1, fminx)</span><br><span class="line">            ##两条斜线</span><br><span class="line">            else:</span><br><span class="line">                if b1 !&#x3D; b2:</span><br><span class="line">                    return []</span><br><span class="line">                else:</span><br><span class="line">                    if x1 &lt;&#x3D; x2:</span><br><span class="line">                        fminx &#x3D; x1</span><br><span class="line">                        #这里实际上不是最小，但是为了区分对应，故意写成这样</span><br><span class="line">                        fminy &#x3D; y1</span><br><span class="line">                        fmaxx &#x3D; x2</span><br><span class="line">                        fmaxy &#x3D; y2</span><br><span class="line">                    else:</span><br><span class="line">                        fminx &#x3D; x2</span><br><span class="line">                        # 这里实际上不是最小，但是为了区分对应，故意写成这样</span><br><span class="line">                        fminy &#x3D; y2</span><br><span class="line">                        fmaxx &#x3D; x1</span><br><span class="line">                        fmaxy &#x3D; y1</span><br><span class="line"></span><br><span class="line">                    if x1_1 &lt;&#x3D; x2_1:</span><br><span class="line">                        sminx &#x3D; x1_1</span><br><span class="line">                        #这里实际上不是最小，但是为了区分对应，故意写成这样</span><br><span class="line">                        sminy &#x3D; y1_1</span><br><span class="line">                        smaxx &#x3D; x2_1</span><br><span class="line">                        smaxy &#x3D; y2_1</span><br><span class="line">                    else:</span><br><span class="line">                        sminx &#x3D; x2_1</span><br><span class="line">                        # 这里实际上不是最小，但是为了区分对应，故意写成这样</span><br><span class="line">                        sminy &#x3D; y2_1</span><br><span class="line">                        smaxx &#x3D; x1_1</span><br><span class="line">                        smaxy &#x3D; y1_1</span><br><span class="line">                    #判断哪条在坐标轴上更偏右</span><br><span class="line">                    if fmaxx &gt;&#x3D; smaxx:</span><br><span class="line">                        if fminx &gt; smaxx:</span><br><span class="line">                            return []</span><br><span class="line">                        else:</span><br><span class="line">                            if fminx &lt;&#x3D; sminx:</span><br><span class="line">                                return (sminx,sminy)</span><br><span class="line">                            else:</span><br><span class="line">                                return (fminx,fminy)</span><br><span class="line"></span><br><span class="line">                    else:</span><br><span class="line">                        if sminx &gt; fmaxx:</span><br><span class="line">                            return []</span><br><span class="line">                        else:</span><br><span class="line">                            if sminx &lt; fminx:</span><br><span class="line">                                return (fminx,fminy)</span><br><span class="line">                            else:</span><br><span class="line">                                return (sminx,sminy)</span><br><span class="line">                    # if fmaxx &lt; sminx or fminx &gt; smaxx:</span><br><span class="line">                    #     return []</span><br><span class="line">                    # if fmaxx &gt;&#x3D; sminx:</span><br><span class="line">                    #     return (sminx, sminy)</span><br><span class="line">                    # if fminx &lt;&#x3D; smaxx:</span><br><span class="line">                    #     return (fminx,fminy)</span><br><span class="line"></span><br><span class="line">        if k1 &#x3D;&#x3D; float(&#39;inf&#39;) and k2 &#x3D;&#x3D; 0:</span><br><span class="line">            if y1 &lt;&#x3D; y2:</span><br><span class="line">                fminy &#x3D; y1</span><br><span class="line">                fmaxy &#x3D; y2</span><br><span class="line">            else:</span><br><span class="line">                fminy &#x3D; y2</span><br><span class="line">                fmaxy &#x3D; y1</span><br><span class="line">            if x1_1 &lt;&#x3D; x2_1:</span><br><span class="line">                sminx &#x3D; x1_1</span><br><span class="line">                smaxx &#x3D; x2_1</span><br><span class="line">            else:</span><br><span class="line">                sminx &#x3D; x2_1</span><br><span class="line">                smaxx &#x3D; x1_1</span><br><span class="line">            if sminx &lt;&#x3D; x1 and smaxx &gt;&#x3D; x1 and y2 &gt;&#x3D; fminy and y2 &lt;&#x3D; fmaxy:</span><br><span class="line">                return (x1,y2)</span><br><span class="line"></span><br><span class="line">        elif k2 &#x3D;&#x3D; float(&#39;inf&#39;) and k1 &#x3D;&#x3D; 0:</span><br><span class="line">            if y1_1 &lt;&#x3D; y2_1:</span><br><span class="line">                sminy &#x3D; y1_1</span><br><span class="line">                smaxy &#x3D; y2_1</span><br><span class="line">            else:</span><br><span class="line">                sminy &#x3D; y2_1</span><br><span class="line">                smaxy &#x3D; y1_1</span><br><span class="line">            if x1 &lt;&#x3D; x2:</span><br><span class="line">                fminx &#x3D; x1</span><br><span class="line">                fmaxx &#x3D; x2</span><br><span class="line">            else:</span><br><span class="line">                fminx &#x3D; x2</span><br><span class="line">                fmaxx &#x3D; x1</span><br><span class="line">            if fminx &lt;&#x3D; x1_1 and fmaxx &gt;&#x3D; x1_1 and y1 &gt;&#x3D; sminy and y1 &lt;&#x3D; smaxy:</span><br><span class="line">                return (x2, y1)</span><br><span class="line">        elif k1 &#x3D;&#x3D; float(&#39;inf&#39;) and k2 !&#x3D; 0 and k2 !&#x3D; float(&#39;inf&#39;):</span><br><span class="line">            y &#x3D; k2 * x1 + b2</span><br><span class="line">            return judge(x1,y1,x2,y2,x1_1,y1_1,x2_1,y2_1,x1,y)</span><br><span class="line">        elif k2 &#x3D;&#x3D; float(&#39;inf&#39;) and k1 !&#x3D;0 and k1 !&#x3D; float(&#39;inf&#39;):</span><br><span class="line">            y &#x3D; k1 * x1_1 + b1</span><br><span class="line">            return judge(x1, y1, x2, y2, x1_1, y1_1, x2_1, y2_1, x1_1, y)</span><br><span class="line"></span><br><span class="line">        x &#x3D; (b2 - b1) &#x2F; (k1 - k2)</span><br><span class="line">        y &#x3D; k1*x + b1</span><br><span class="line"></span><br><span class="line">        return judge(x1,y1,x2,y2,x1_1,y1_1,x2_1,y2_1,x,y)</span><br></pre></td></tr></table></figure><p>好了，这道题目暂时到这结束，不算很难，但是需要仔细分析。</p><h2 id="5-设计一个简化版的推特"><a href="#5-设计一个简化版的推特" class="headerlink" title="5.设计一个简化版的推特"></a>5.设计一个简化版的推特</h2><p>你的设计需要支持以下的几个功能：</p><ol><li>postTweet(userId, tweetId): 创建一条新的推文</li><li>getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。</li><li>follow(followerId, followeeId): 关注一个用户</li><li>unfollow(followerId, followeeId): 取消关注一个用户</li></ol><p>今天的题目比前两天都要简单，没有什么复杂的边界或者数学问题。可以直接利用两个字典来实现。具体分析一下功能</p><ol><li>声明两个字典content，star，分别存储用户发的twitter和关注，对应的key都为userid</li><li>发推特：<ul><li>利用time模块，记录时间戳，然后与twitterid 封装成 “twitterid-时间戳”的格式存入到content中</li><li>注意点，由于操作速度很快，可能需要sleep，以此分辨推特的先后顺序</li></ul></li><li>关注用户：<ul><li>先判断userid是否在star中，若不存在，则创建，然后加入对应的id</li></ul></li><li>取关<ul><li>先判断userid是否在star中，若存在，再判断取关对象的id是否在对应的value中，若存在，则移除</li></ul></li><li>获取最近的十条消息<ul><li>先从content中取出用户自己所发推特，如果用户没有关注对象，则直接按顺序返回用户的最近十条推特</li><li>若用户有关注对象，则取出对象id，然后从content中取出对应的推特（如果该用户发过推特），然后和用户所发推特组成新的列表。接下来遍历该列表。取出对应的value值，利用split得到对应id和时间戳，将其中时间戳最大的的放入结果集中，然后移除该值，进行下轮迭代。如果发现迭代出来的有相同id，则此轮迭代不计数，进行下一轮，总共取到十条记录为止</li></ul></li></ol><p>大致的思路就这样，没有难点，下面就附上代码，仅供参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import copy</span><br><span class="line">class Twitter:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Initialize your data structure here.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.star &#x3D; &#123;&#125;</span><br><span class="line">        self.content&#x3D;&#123;&#125;</span><br><span class="line"></span><br><span class="line">    def postTweet(self, userId: int, tweetId: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Compose a new tweet.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        #运行速度太快。。无法精准计算时间，故休眠</span><br><span class="line">        time.sleep(0.001)</span><br><span class="line">        ticks &#x3D; time.time()</span><br><span class="line">        if userId not in self.content:</span><br><span class="line">            self.content[userId] &#x3D; []</span><br><span class="line">            self.content[userId].append(str(tweetId) + &#39;-&#39; + str(ticks))</span><br><span class="line">        else:</span><br><span class="line">            self.content[userId].append(str(tweetId) + &#39;-&#39; + str(ticks))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def getNewsFeed(self, userId: int):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Retrieve the 10 most recent tweet ids in the user&#39;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if userId in self.content:</span><br><span class="line">            mycontent &#x3D; copy.deepcopy(self.content[userId])</span><br><span class="line">        else:</span><br><span class="line">            mycontent &#x3D; []</span><br><span class="line">        if userId in self.star:</span><br><span class="line">            followees &#x3D; copy.deepcopy(self.star[userId])</span><br><span class="line">        else:</span><br><span class="line">            followees &#x3D; []</span><br><span class="line">        fcontent &#x3D; []</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        tweetId &#x3D; 0</span><br><span class="line">        if followees :</span><br><span class="line">            for id in followees:</span><br><span class="line">                #判断用户是否发过twitter</span><br><span class="line">                if id in self.content:</span><br><span class="line">                    fcontent.extend(self.content[id])</span><br><span class="line"></span><br><span class="line">            mycontent.extend(fcontent)</span><br><span class="line">            #print(&quot;mycontent&quot;,mycontent)</span><br><span class="line">            i&#x3D;0</span><br><span class="line">            while i &lt;&#x3D; 9:</span><br><span class="line">                min &#x3D; float(&#39;-inf&#39;)</span><br><span class="line">                if mycontent:</span><br><span class="line">                    for val in mycontent:</span><br><span class="line">                        #print(val)</span><br><span class="line">                        tmp &#x3D; val.split(&#39;-&#39;)</span><br><span class="line">                        posttime &#x3D; float(tmp[1])</span><br><span class="line">                        if posttime &gt; min:</span><br><span class="line">                            tweetId &#x3D; tmp[0]</span><br><span class="line">                            min &#x3D; posttime</span><br><span class="line">                    if tweetId not in res:</span><br><span class="line">                        res.append(tweetId)</span><br><span class="line">                        i &#x3D; i + 1</span><br><span class="line"></span><br><span class="line">                    mycontent.remove(str(tweetId) + &#39;-&#39; + str(min))</span><br><span class="line"></span><br><span class="line">                else:</span><br><span class="line">                    break</span><br><span class="line">            return res</span><br><span class="line">        else:</span><br><span class="line">            for i in range(10):</span><br><span class="line">                if mycontent:</span><br><span class="line">                    id &#x3D; mycontent.pop().split(&#39;-&#39;)[0]</span><br><span class="line">                    if id not in res:</span><br><span class="line">                        res.append(id)</span><br><span class="line">                else:</span><br><span class="line">                    break</span><br><span class="line">            return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def follow(self, followerId: int, followeeId: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Follower follows a followee. If the operation is invalid, it should be a no-op.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if followerId not in self.star:</span><br><span class="line">            self.star[followerId] &#x3D; []</span><br><span class="line">            self.star[followerId].append(followeeId)</span><br><span class="line">        else:</span><br><span class="line">            self.star[followerId].append(followeeId)</span><br><span class="line"></span><br><span class="line">    def unfollow(self, followerId: int, followeeId: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Follower unfollows a followee. If the operation is invalid, it should be a no-op.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if followerId in self.star:</span><br><span class="line">            if followeeId in self.star[followerId]:</span><br><span class="line">                self.star[followerId].remove(followeeId)</span><br></pre></td></tr></table></figure><h2 id="6-两数相加-II"><a href="#6-两数相加-II" class="headerlink" title="6.两数相加 II"></a>6.两数相加 II</h2><p>要求：给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>进阶：</p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p>要求是很简单的，只要两数和，难点是数字是存放在链表中的，所以我们要写遍历链表，将取出的数字放进列表中。然后判断两个列表的长度，将长的设置为big，另一个叫small,然后在分析：</p><ol><li>首先 我们在small不为空的条件下，同时对small和big进行pop操作，然后将其相加，再判断是否和大于等于10，若大于等于10，则将结果减去10在将入res，同时将b置为1。否则直接将结果加入res，b置为0</li><li>然后在big不为空的情况下，计算big.pop与b的和。在重复条件一后面的判断。这里其实是相加的两个数位数不同的情况下的计算。</li><li>最后在big也为空列表的情况下，判断b是否为1，也就是是否存在进位的问题，若为1，则在res中加1。这里是计算20+80这种情况。</li></ol><p>最后我们有了结果集res。由于题目要求是返回链表，所以我们遍历结果集，重新生成链表就行了。</p><p>下面附上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        arr1 &#x3D; []</span><br><span class="line">        arr2 &#x3D; []</span><br><span class="line">        f1 &#x3D; f2 &#x3D; True</span><br><span class="line">        while f1:</span><br><span class="line">            arr1.append(l1.val)</span><br><span class="line">            if l1.next !&#x3D; None:</span><br><span class="line">                l1 &#x3D; l1.next</span><br><span class="line">            else:</span><br><span class="line">                f1 &#x3D; False</span><br><span class="line">        while f2:</span><br><span class="line">            arr2.append(l2.val)</span><br><span class="line">            if l2.next !&#x3D; None:</span><br><span class="line">                l2 &#x3D; l2.next</span><br><span class="line">            else:</span><br><span class="line">                f2 &#x3D; False</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        if len(arr1) &gt;&#x3D; len(arr2):</span><br><span class="line">            big &#x3D; arr1</span><br><span class="line">            small &#x3D; arr2</span><br><span class="line">        else:</span><br><span class="line">            big &#x3D; arr2</span><br><span class="line">            small &#x3D; arr1</span><br><span class="line">        #b为进位数</span><br><span class="line">        b &#x3D; 0</span><br><span class="line">        while small !&#x3D; []:</span><br><span class="line">            result &#x3D; big.pop() + small.pop() + b</span><br><span class="line">            if  result &gt;&#x3D; 10:</span><br><span class="line">                res.insert(0,result-10)</span><br><span class="line">                b &#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                res.insert(0,result)</span><br><span class="line">                b &#x3D; 0</span><br><span class="line"></span><br><span class="line">        while big !&#x3D; []:</span><br><span class="line">            result &#x3D; big.pop() + b</span><br><span class="line">            if  result &gt;&#x3D; 10 :</span><br><span class="line">                res.insert(0,result-10)</span><br><span class="line">                b &#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                res.insert(0,result)</span><br><span class="line">                b &#x3D; 0</span><br><span class="line"></span><br><span class="line">        if big &#x3D;&#x3D; [] and b &#x3D;&#x3D; 1:</span><br><span class="line">            res.insert(0,b)</span><br><span class="line"></span><br><span class="line">        cache &#x3D; None</span><br><span class="line">        for i in res:</span><br><span class="line">            tmp &#x3D; ListNode(i)</span><br><span class="line">            if cache !&#x3D; None:</span><br><span class="line">                cache.next &#x3D; tmp</span><br><span class="line">                cache &#x3D; tmp</span><br><span class="line">            else:</span><br><span class="line">                head &#x3D; ListNode(i)</span><br><span class="line">                cache &#x3D; head</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure><h2 id="7-两数之和"><a href="#7-两数之和" class="headerlink" title="7.两数之和"></a>7.两数之和</h2><p>要求：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>今天的题目很简单，利用python可以很简单的实现。遍历数组，用target减去当前值，若他们的差在剩余的数组中，则有解，否则进行下一轮迭代。</p><p>代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        length &#x3D; len(nums)</span><br><span class="line">        while i &lt; length - 1:</span><br><span class="line">            sub &#x3D; target - nums[i]</span><br><span class="line">            if sub in nums[i + 1:]:</span><br><span class="line">                return (i,i + nums[i + 1:].index(sub)+1)</span><br><span class="line">            i +&#x3D; 1</span><br></pre></td></tr></table></figure><h2 id="8-合并区间"><a href="#8-合并区间" class="headerlink" title="8.合并区间"></a>8.合并区间</h2><p>要求：给出一个区间的集合，请合并所有重叠的区间。</p><p>就是说给出[1,4],[4,5]可以将其合并成[1,5]，即两个区间如果有交集，就可以将他们合并。对于这种问题，我们可以将集合先从小到大排序，然后从头开始比较，分别有以下几种情况</p><ol><li>当左区间的右端点小于右区间的左端点时，不能合并</li><li>当左区间的右端点大于等于右区间的左端点时，可以合并，但是要分情况：<ul><li>当左区间的左端点A小于右区间的左端点C时，合并后区间的左端点的值为A,否则为C</li><li>当左区间的右端点B小于右区间的右端点D时，合并后区间的右端点的值为D,否则为B</li></ul></li></ol><p>这样就得到了合并后的区间，我们将其插入到原集合中，并从原集合中删除被合并的区间，进行下一轮迭代。这样到最后就可以得到所有合并后的区间，下面贴上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:</span><br><span class="line">        if intervals &#x3D;&#x3D; []:</span><br><span class="line">            return []</span><br><span class="line">        row, col &#x3D; len(intervals), len(intervals[0])</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        intervals.sort()</span><br><span class="line">        while i + 1 &lt; row:</span><br><span class="line">            if intervals[i][col - 1] &gt;&#x3D; intervals[i + 1][0]:</span><br><span class="line">                tmp1 &#x3D; intervals[i]</span><br><span class="line">                tmp2 &#x3D; intervals[i + 1]</span><br><span class="line">                mergearr &#x3D; []</span><br><span class="line">                if intervals[i][0] &lt;&#x3D; intervals[i + 1][0]:</span><br><span class="line">                    mergearr.append(intervals[i][0])</span><br><span class="line">                else:</span><br><span class="line">                    mergearr.append(intervals[i + 1][0])</span><br><span class="line">                if intervals[i][col - 1] &gt;&#x3D; intervals[i + 1][col - 1]:</span><br><span class="line">                    mergearr.append(intervals[i][col - 1])</span><br><span class="line">                else:</span><br><span class="line">                    mergearr.append(intervals[i + 1][col - 1])</span><br><span class="line">                intervals.remove(tmp1)</span><br><span class="line">                intervals.remove(tmp2)</span><br><span class="line">                intervals.insert(0, mergearr)</span><br><span class="line">                row &#x3D; len(intervals)</span><br><span class="line">                i &#x3D; 0</span><br><span class="line">                intervals.sort()</span><br><span class="line">            else:</span><br><span class="line">                i +&#x3D; 1</span><br><span class="line">        return intervals</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 深度遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NexT升级过程中遇到的坑</title>
      <link href="/posts/cbb37015.html"/>
      <url>/posts/cbb37015.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="/js/baidu.js"></script><script type="text/javascript" src="/js/360.js"></script><h1 id="NexT从5-1-x-—-gt-7-8-0-中遇到的坑"><a href="#NexT从5-1-x-—-gt-7-8-0-中遇到的坑" class="headerlink" title="NexT从5.1.x  —&gt; 7.8.0 中遇到的坑"></a>NexT从5.1.x  —&gt; 7.8.0 中遇到的坑</h1><blockquote><p>今天闲来无事，发现NexT已经更新到7.8.0，而自己前几天刚刚搭好的博客还是5.1版本，内心十万只羊驼呼啸而过。。。虽然很不情愿，但本着早生晚生都要生的态度，就决定在折腾一把，进行升级。。。谨以此文，纪念我升级过程中遇到的大坑。</p></blockquote><a id="more"></a><p>升级过程其实很简单，直接从github上clone下来就行了，<a href="git clone https://github.com/theme-next/hexo-theme-next themes/">具体可以参考官方文档</a>，这里不过多阐述。直接说遇到的坑吧！</p><ul><li><h2 id="显示的字体变成梵文？？"><a href="#显示的字体变成梵文？？" class="headerlink" title="显示的字体变成梵文？？"></a>显示的字体变成梵文？？</h2><p>其实这个问题是因为没有好好看官方文档导致的。。在5.1版本中，中文设置是叫zh-Hans，在新版本中，中文应该设置为 zh-CN 。之后之间刷新就好了，如果没有效果，先clean一下，之后正常显示中文了。</p></li></ul><ul><li><h2 id="给文章添加的阴影效果不见了"><a href="#给文章添加的阴影效果不见了" class="headerlink" title="给文章添加的阴影效果不见了"></a>给文章添加的阴影效果不见了</h2></li></ul><p>在5.1版本中，可以通过修改_custom下的custom.styl来覆盖原有样式，但是在新版本中，目录结构发生了变换，导致这个方法失效了，所以只能通过其他手段实现。然后在<strong>主题配置</strong>文件中，可以找到以下配置：</p><p><img src="https://i.loli.net/2020/04/07/HnJgxFha7VvdBMj.png" alt></p><p>我们将红框圈出来的这一行的注释去掉，然后在 <strong>站点根目录</strong>下的source目录下，新建_data目录，再新建styles.styl。走到这一步，原本以为成功了，将之前代码复制进去，发现还是没有用。。。后来发现是因为样式名已经变了，所以需要重写，下面是添加的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.use-motion &#123;</span><br><span class="line">if (hexo-config(&#39;motion.transition.post_block&#39;)) &#123;</span><br><span class="line">.post-block &#123;</span><br><span class="line">   opacity: 0;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">&#125;</span><br><span class="line">.pagination, .comments &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在执行hexo clean &amp; hexo s ，就可以在本地看到消失的阴影框又出现了。</p><ul><li><h2 id="文章置顶的功能"><a href="#文章置顶的功能" class="headerlink" title="文章置顶的功能"></a>文章置顶的功能</h2></li></ul><p>这个功能其实还好，和5.1版本一样，直接修改 themes*\layout\_macro目录下的post.swig</p><p>定位到 div class=”post-meta” 标签下，插入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">    &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;font color&#x3D;green&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>然后保存刷新，就可以看到效果了。（首先要安装hexo-generator-index-pin-top插件，以及卸载掉原本的hexo-generator-index插件）</p><ul><li><h2 id="添加文章阅读标记"><a href="#添加文章阅读标记" class="headerlink" title="添加文章阅读标记"></a>添加文章阅读标记</h2></li></ul><p>这个功能其实也和老版本一样，没有改动。在<code>\themes\*\layout\_macro</code>中新建<code>passage-end-tag.swig</code>文件，然后添加以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style&#x3D;&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------已经触及底线啦&lt;i class&#x3D;&quot;fa fa-paw&quot;&gt;&lt;&#x2F;i&gt;感谢您的阅读-------------&lt;&#x2F;div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>接着在统计目录下，修改post.swig,在<code>post-body</code>后，<code>END POST BODY</code>前，添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &#39;passage-end-tag.swig&#39; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>最后在<strong>主题配置文件</strong>中 ，添加以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure><p>这样可以实现阅读结束标记了==</p><ul><li><h2 id="不蒜子-不显示"><a href="#不蒜子-不显示" class="headerlink" title="不蒜子 不显示"></a>不蒜子 不显示</h2><p>在更新的7.8版本中，有关于不蒜子的设置，将其设置为true后，还是不显示访问人数，在baidu后发现都是说调用api出错，但是经过查看后发现，api并没有错。。。所以在打开开发者模式后才发现，不蒜子的数据是有的，但是样式后面加上了display:none。。。所以该样式并没有显示。然后在themes\your_theme\layout_third-party\statistics目录下打开busuanzi-counter.swig以及themes\your_theme\layout_macro目录下的post.swig,果然发现了该样式，如图:</p><p><img src="https://i.loli.net/2020/04/07/rSPbIfQn1gl3iUC.png"></p></li></ul><p>  <img src="https://i.loli.net/2020/04/07/rv6Xut9LGczRyqY.png" alt></p><p>  然后直接将样式修改为”display: inline-flex;”,重新启动，果然主页数据出来的，但是点进去具体文章页面，还是没有访问统计。。。实在无语，索性在之前添加的自定义样式文件styles.styl中，添加以下代码，强制覆盖CSS样式：</p><p>  <img src="https://i.loli.net/2020/04/07/LIqgQOTmkafZwRY.png" alt></p><p>  然后执行hexo clean &amp; hexo s ，清除一下缓存，就可以看到数据显示咯~终于成功了，属实坑爹。。</p><p>  效果如下图：</p><p>  <img src="https://i.loli.net/2020/04/07/gAcD6nksmPJd4Ty.png" alt></p><p>  <img src="https://i.loli.net/2020/04/07/XLHCYn6mjWx7VE2.png" alt></p><p>  <img src="https://i.loli.net/2020/04/07/hXeKVJCOzQRZWod.png" alt></p><hr><p>目前就遇到这些问题，如果遇到新问题，还是会追加更新的~</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
          <category> next </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本升级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>neural-networks-deep-learning-week4</title>
      <link href="/posts/d78210a7.html"/>
      <url>/posts/d78210a7.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="/js/360.js"></script><script type="text/javascript" src="/js/baidu.js"></script><h1 id="Deep-Learning-深层神经网络"><a href="#Deep-Learning-深层神经网络" class="headerlink" title="[Deep Learning] 深层神经网络"></a>[Deep Learning] 深层神经网络</h1><p>本周目标：</p><ul><li><p>将深层神经网络视为一个接一个的连续块</p></li><li><p>建立和训练深层L层神经网络</p></li><li><p>分析矩阵和向量维数以检查神经网络的实现。</p></li><li><p>了解如何使用缓存将信息从正向传播传递到反向传播。</p></li><li><p>了解超参数在深度学习中的作用</p><a id="more"></a></li></ul><hr><h1 id="块的思想"><a href="#块的思想" class="headerlink" title="块的思想"></a>块的思想</h1><ul><li>对于每层的计算，可以将其视为一个块，如下图</li></ul><p>  <img src="https://i.loli.net/2020/04/06/I8hkFCdOqEYH1bm.jpg" alt></p><p>  对于此图，只需要理解其过程即可，在前向传播过程中，将变量Z1,Z2等等存储起来，然后在反向传播过程中，就可以很方便地使用他们。</p><h1 id="检查矩阵维度"><a href="#检查矩阵维度" class="headerlink" title="检查矩阵维度"></a>检查矩阵维度</h1><ul><li><p>在写代码过程中，检查各个参数的维度，能有效的避免一些奇怪的BUG。用下图举个栗子</p><p><img src="https://i.loli.net/2020/04/06/74IfwvqOrUk5Wb2.png" style="zoom:50%;"></p><p>如图所示，这是一个五层的神经网络，有参数<script type="math/tex">W^{[1]},b^{[1]}...</script>  首先，先确定<script type="math/tex">W^{[1]}</script>的维度，可以看到，第一个隐藏层有三个单元，即 <script type="math/tex">n^{[1]} = 3</script> ,而输入为<script type="math/tex">x_1,x_2</script>，即<script type="math/tex">n^{[0]}=n_x=2</script>,可以看做是一个 <strong>2 x 1</strong>的列向量。又有<script type="math/tex">z^{[1]} = W^{[1]}x + b^{[1]}</script>,先忽略<script type="math/tex">b^{[1]}</script>，我们已经知道<script type="math/tex">z^{[1]}</script>是 <strong>3 x 1</strong> 的列向量，那么根据线性代数的有关知识，可以直接推断出<script type="math/tex">W^{[1]}</script>是 <strong>3 x 2</strong> 的矩阵。<strong>（若有 A矩阵 的维度为 m x k ,B矩阵的维度为 k x n,那么 AB矩阵相乘得到的矩阵C的维度为 m x n）</strong>。那<script type="math/tex">b^{[1]}</script>的矩阵维度为 <strong>3 x 1</strong>。同理，我们可以推断出 <script type="math/tex">W^{[2]}</script>的维度为 <strong>4 x 3</strong>，<script type="math/tex">b^{[2]}</script> 的维度为 <strong>4 x 1</strong> …..</p><p>由此，可以归纳出一个维度公式，即对于第k层中<strong>(k&gt;0）</strong>，有</p><script type="math/tex; mode=display">\begin{array}\\W^{[k]}的维度 = n^{[k]} * n^{[k-1]} \\b^{[k]}的维度 = n^{[k]} * 1\end{array}</script><p>得到每个参数的维度后，就可以很方便的检验运算是否正确咯。</p></li></ul><h1 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h1><ul><li><h2 id="什么是超参数"><a href="#什么是超参数" class="headerlink" title="什么是超参数"></a>什么是超参数</h2><ul><li>在整个NN中，有许多参数，比如<script type="math/tex">W^{[1]},b^{[1]},W^{[2]},b^{[2]}</script>等等，还有一些其他参数，比如<script type="math/tex">学习率\alpha，迭代次数\#iterations,隐藏层数L，隐藏单元个数n^{[l]},激活函数等等</script>。 而这些这参数都会影响到最终的W,b的结果，所以这些参数就被称作超参数。实际上还有很多超参数，具体的会在之后详细谈及。</li></ul></li><li><h2 id="超参数的作用"><a href="#超参数的作用" class="headerlink" title="超参数的作用"></a>超参数的作用</h2><ul><li><p>在深度学习算法中的超参数如何取值是一个以实验为依据的过程，有时候，可能依赖直觉，比如设置<script type="math/tex">\alpha = 0.01</script>,然后实际操作了一下，得到了某个结果，但是对这个结果不满意，于是把<script type="math/tex">\alpha</script>的值增加到0.05。</p><p>大部分情况下，都很难提前知道这些超参数的最优解，所以具体的取值其实是一个基于试验的过程，在过程中发现新的最优解。</p></li></ul></li></ul><h1 id="多层NN反向传播"><a href="#多层NN反向传播" class="headerlink" title="多层NN反向传播"></a>多层NN反向传播</h1><ul><li><p>在这里，我们具体讨论一下，关于多层网络的反向传播算法。对于前向传播，相信大家应该都很熟悉了，这列就不过多陈述了。主要还是反向传播（Back Propagation，简称BP）。在BP中，第一层的输入应该是在<script type="math/tex">da^{[l]}</script>,而输出是<script type="math/tex">dW^{[l]},db^{[l]}</script>。 </p><p>假设一共有L层网络，Y为真实的label，则在第L层，有</p><script type="math/tex; mode=display">\begin{array}\\dZ^{[L]} = A^{[L]} - Y \\dW^{[L]} = \left(\frac{1}{m}\right) dZ^{[L]}  A^{[L-1]T} \\db^{[L]} = \left(\frac{1}{m}\right)dZ^{[L]}\end{array}</script></li></ul><p>  对于接下来的L-1层，有</p><script type="math/tex; mode=display">  \begin{array}  \\  dZ^{[L-1]} = W^{[L]T} dZ^{[L]} * g^{[L]'}(Z^{[L-1]})  \\  dW^{[l-1]} = \left(\frac{1}{m}\right) dZ^{[L-1]} * A^{[L-2]T} \\  db^{[L-1]} = \left(\frac{1}{m}\right)dZ^{[L-1]}  \end{array}</script><p>  这里公式是针对<font color="gree">所有样本</font>而言，且认为是做二元分类，即最后的<font color="gree">激活函数为sigmoid</font>。 <font color="gree">*</font>  代表 对应元素相乘，即A矩阵为 m x n, B矩阵为 m x n ，那么A * B 依旧是 m x n的矩阵。有了对应的梯度，我们就可以利用for循环来实现对L层网络的反向传播，这里要注意第一次梯度下降时要分开。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>neural-networks-deep-learning-week3</title>
      <link href="/posts/49e68504.html"/>
      <url>/posts/49e68504.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="/js/baidu.js"></script><script type="text/javascript" src="/js/360.js"></script><h1 id="Deep-Learning-浅层神经网络"><a href="#Deep-Learning-浅层神经网络" class="headerlink" title="[Deep Learning] 浅层神经网络"></a>[Deep Learning] 浅层神经网络</h1><ul><li>理解隐藏层和隐藏单元</li><li>能够使用多种类型的激活函数</li><li>用隐藏层建立一个前向传播和反向传播算法</li><li>应用随机初始化</li></ul><a id="more"></a><h2 id="浅层神经网络结构"><a href="#浅层神经网络结构" class="headerlink" title="浅层神经网络结构"></a>浅层神经网络结构</h2><ul><li><h3 id="单样本前向传播"><a href="#单样本前向传播" class="headerlink" title="单样本前向传播"></a>单样本前向传播</h3><p>首先，看一下神经网络的结构图 </p><p><img src="https://i.loli.net/2020/04/08/BVQtXdyYAgEn2pc.png" alt></p></li></ul><p>这是一个两层的神经网络（输入层不算做一层，认为是第0层）。一般用 <strong>X</strong> 代表输入，也可以用 <script type="math/tex">a^{[0]}</script> 表示 （a代  表激活的意思），用<script type="math/tex">a^{[1]}</script>代表第一层即隐藏层，<script type="math/tex">a^{[2]}</script>代表输出层。所以上图中 ，<strong>X</strong> = <script type="math/tex">a^{[0]}</script> <script type="math/tex">\in R^{3}</script> ,<script type="math/tex">a^{[1]} \in R^{4}</script>,<script type="math/tex">a^{[2]}\in R</script> 。 现在来看隐藏层第一个节点即<script type="math/tex">a^{[1]}_{1}</script>的计算，这个计算和逻辑回归一样。首先算出</p><script type="math/tex; mode=display">z^{[1]}_1 = w^{[1]T}_1x + b^{[1]}_1</script><p> 然后计算</p><script type="math/tex; mode=display">a^{[1]}_1 = sigmoid(z^{[1]}_1)</script><p> 其他节点 同理计算，整理一下</p><script type="math/tex; mode=display">z^{[1]}_1 = w^{[1]T}_1x + b^{[1]}_1,a^{[1]}_1 = sigmoid(z^{[1]}_1)</script><script type="math/tex; mode=display">z^{[1]}_2 = w^{[1]T}_2x + b^{[1]}_2,a^{[1]}_2=sigmoid(z^{[1]}_1)</script><script type="math/tex; mode=display">z^{[1]}_3 = w^{[1]T}_3x + b^{[1]}_3,a^{[1]}_3=sigmoid(z^{[1]}_3)</script><script type="math/tex; mode=display">z^{[1]}_4 = w^{[1]T}_4x + b^{[1]}_4,a^{[1]}_4=sigmoid(z^{[1]}_4)</script><ul><li><h3 id="前向传播向量化"><a href="#前向传播向量化" class="headerlink" title="前向传播向量化"></a>前向传播向量化</h3><p>接下来将这几个式子向量化</p></li></ul><script type="math/tex; mode=display">\left[ \begin{matrix}   --w^{[1]T}_1-- \\   --w^{[1]T}_2-- \\   --w^{[1]T}_3-- \\   --w^{[1]T}_4--   \end{matrix}  \right] *\left[\begin{matrix}   x_1 \\   x_2 \\   x_3\end{matrix}\right]   + \left[\begin{matrix}b^{1}_1 \\b^{1}_2 \\b^{1}_3 \\b^{1}_4\end{matrix}\right]=\left[\begin{matrix}w^{[1]T}_1x + b^{[1]}_1 \\w^{[1]T}_2x + b^{[1]}_2 \\w^{[1]T}_3x + b^{[1]}_3 \\w^{[1]T}_4x + b^{[1]}_4 \end{matrix}\right]=\left[\begin{matrix} z^{[1]}_1 \\ z^{[1]}_2 \\ z^{[1]}_3 \\ z^{[1]}_4 \\\end{matrix}\right]</script><p>​      第一个矩阵为4 x 3的矩阵 ,这是因为 <script type="math/tex">w^{1}_l</script>都属于 三维列向量，现在将他们的转置竖直拼  接为新的矩阵，所以维度4x3。简化一下，可以得到下面的公式</p><script type="math/tex; mode=display">z^{[1]} = W^{[1]} x + b^{[1]}</script><script type="math/tex; mode=display">a^{[1]} = sigmoid(z^{[1]})</script><script type="math/tex; mode=display">z^{[2]} = W^{[2]}a^{[1]} + b^{[2]}</script><script type="math/tex; mode=display">a^{[2]} = sigmoid(z^{[2]})</script><p>​      因为 x 可以写作<script type="math/tex">a^{[0]}</script>,所以</p><script type="math/tex; mode=display">z^{[1]} = W^{[1]} a^{[0]} + b^{[1]}</script><p>​      其中，<script type="math/tex">W^{[1]} \in R^{4*3},b\in R^{4*1}, W^{[2]}\in R^{1*4},b^{[2]} \in R</script>,所以最后 <script type="math/tex">a^{[2]}</script> 也是一个实数。</p><p>​     到此，就完成了一个实例的神经网络计算。</p><ul><li><h3 id="多样本前向传播"><a href="#多样本前向传播" class="headerlink" title="多样本前向传播"></a>多样本前向传播</h3></li></ul><p>  接下来 讨论一下对于多个样本的计算：</p><p>  首先解释一下符号的意思， 第<strong>i</strong>个样本第<strong>k</strong>层的节点定义为 <script type="math/tex">a^{[k](i)}</script>。</p><p>  则在计算m个样本的时候，需要像下面这样计算</p><p><strong>for i = 1 to m:</strong></p><script type="math/tex; mode=display">z^{[1](i)} = W^{[1]} x^{(i)} + b^{[1]}</script><script type="math/tex; mode=display">a^{[1](i)} = sigmoid(z^{[1](i)})</script><script type="math/tex; mode=display">z^{[2](i)} = W^{[2]}a^{[1](i)} + b^{[2]}</script><script type="math/tex; mode=display">a^{[2](i)} = sigmoid(z^{[2](i)})</script><ul><li><h3 id="多样本前向传播向量化"><a href="#多样本前向传播向量化" class="headerlink" title="多样本前向传播向量化"></a>多样本前向传播向量化</h3><p>首先将多个x样本水平拼接为<strong>X</strong>，维度为 n x m ，即</p></li></ul><script type="math/tex; mode=display">  X =   \left[  \begin{matrix}  | & |  &  | \\  x^{(1)} & x^{(2)} & x^{(3)} \\  | & |  &  | \\  \end{matrix} \tag{n * m}  \right]</script><p>  则 向量化 如下</p><script type="math/tex; mode=display">  Z^{[1]} =  W^{[1]} X + b^{[1]}</script><script type="math/tex; mode=display">A^{[1]} = sigmoid(Z^{[1]})</script><script type="math/tex; mode=display">  Z^{[2]} = W^{[2]} A^{[1]} + b^{[2]}</script><script type="math/tex; mode=display">  A^{[2]} = sigmoid(Z^{[2]})</script><p>  同样的 ，<script type="math/tex">Z^{[1]}</script> ，<script type="math/tex">A^{[1]}</script>都是矩阵。到此就已经全部完成了。</p><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><ul><li><h3 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h3><p>目前为止，我们使用的激活函数一直都是sigmoid。它的图像是这样：</p></li></ul><p><img src="https://i.loli.net/2020/03/31/LlMgaBbvCmTZnyr.png" style="zoom:50%;"></p><p>可以看到，当z非常大或者非常小的时候，它斜率也非常小，这样会使梯度下降很慢。所以基本上不会使用这个激活函数。 <font color="red">除非在做二元分类的时候，需要输出值在o-1之间,只有在这个时候会在输出层选择它。需要注意的是，对于隐藏层和输出层来讲，可以选择不同的激活函数。</font></p><ul><li><h3 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h3><p>一般情况下，tanh函数都要优于sigmoid函数，它的图像如下：</p><p><img src="https://i.loli.net/2020/03/31/hzbAeauWGZRItFM.png" style="zoom:50%;"></p><p>它的公式为：</p></li></ul><script type="math/tex; mode=display">tanh = \frac{e^{z} - e^{-z}}{e^{z} + e^{-z}}</script><p>其实是sigmoid函数经过变换后得来的。尽管他的表现要比sigmoid函数要好，但是仍旧面临同样的问题，就是当z过大或过小的时候，斜率非常小。所以也不怎么使用它。</p><ul><li><h3 id="ReLU函数（线性修正单元）"><a href="#ReLU函数（线性修正单元）" class="headerlink" title="ReLU函数（线性修正单元）"></a>ReLU函数（线性修正单元）</h3><p>它的公式为 <strong>ReLU = max(0,z)</strong> , 图像长这样：</p><p><img src="https://i.loli.net/2020/03/31/A3i1mjGnDJQ58YV.png" style="zoom:50%;"></p></li></ul><p>所以只要z为正数，那么斜率就一直为1，z为负数时，斜率为0。虽然当z=0时，导数无定义（左导数和右导数不相等），但是在实际编程时，遇到z=0的概率非常非常小，并且也可以通过指定z=0时，导数为0或者1，所以不用纠结这个问题。</p><p>所以一般情况下都用<strong>ReLU</strong>，或者在你不知道使用哪种激活函数时，就选择它。就比如我们在做二元分类的问题时，可以将所有隐藏层的激活函数都设置为<strong>ReLU</strong>，然后将输出层的激活函数设置为<strong>sigmoid</strong>。</p><p>此外 ，ReLU函数还有另一种版本。</p><ul><li><h3 id="Leaky-ReLU（带泄露的ReLU）"><a href="#Leaky-ReLU（带泄露的ReLU）" class="headerlink" title="Leaky ReLU（带泄露的ReLU）"></a>Leaky ReLU（带泄露的ReLU）</h3></li></ul><p>它的公式为 <strong>ReLU = max(0.01z,z)</strong> , 图像长这样：</p><p><img src="https://i.loli.net/2020/03/31/YEVe8Xv9My4WQZ3.png" style="zoom:50%;"></p><p>当z为负数时，它的斜率不在为0，而是一个轻微的倾斜。这种激活函数实际上使用起来和ReLU没什么太大的区别，具体可以看个人爱好，或者在你的模型中，将两种都尝试一下，来试试效果。</p><p>顺带说一句，因为在NN中，有足够多的隐藏单元来使得z为正数，所以在使用ReLU的时候也不用太担心梯度下降的问题。</p><h2 id="激活函数求导"><a href="#激活函数求导" class="headerlink" title="激活函数求导"></a>激活函数求导</h2><ul><li><h3 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h3><p>关于它的求导，可以参考上一篇博客：<a href="https://www.miraclesky.cn/neural-networks-deep-learning-week2.html" target="_blank" rel="noopener">neural-networks-deep-learning-week2</a></p><p>这里就不再赘述。</p></li><li><h3 id="tanh-函数"><a href="#tanh-函数" class="headerlink" title="tanh 函数"></a>tanh 函数</h3><p>首先，有它的公式</p><script type="math/tex; mode=display">g(z) = tanh(z) = \frac{e^{z} - e^{-z}}{e^{z} + e^{-z}}</script></li></ul><p>  则有</p><script type="math/tex; mode=display">  g^{'}（z） = 1 - (tanh(z))^{2}</script><p>  具体求导过程可以自行求导，不是很难</p><ul><li><h3 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h3><script type="math/tex; mode=display">g(z) = max(0,z)</script><p>求导非常简单</p><script type="math/tex; mode=display">g^{'}(z) = \left\{ \begin{aligned}1 & &if && z\geq0 \\0 & &if && z<0\end{aligned}\right.</script><p>当z=0时，我们手动设置导数为0或者1（在数学中这是不可以的，==该点不可导==）</p></li></ul><h2 id="神经网络中的梯度下降"><a href="#神经网络中的梯度下降" class="headerlink" title="神经网络中的梯度下降"></a><font color="red">神经网络中的梯度下降</font></h2><p>现在需要讨论 在NN 中如何进行梯度下降，假设目前还是做得二元分类问题且只包含一层隐藏层，那么我们有损失函数的定义如下：</p><script type="math/tex; mode=display">J(w^{[1]},b^{[1]},w^{[2]},b^{[2]}) =\frac{1}{m}\sum_{i=1}^m  L(\hat{y}^\left(i\right),y^\left(i\right)) \\其中 ，n_x=n^{[0]}为特征的个数，n^{[1]}为隐藏单元个数，n^{[2]}为输出单元个数\\w^{[1]}的维度 为 n^{[1]} * n^{[0]}，b^{[1]}是一个n^{[1]}维向量，即n^{[1]}*1 \\w^{[1]}的维度 为 n^{[2]} * n^{[1]}，b^{[2]}是一个n^{[2]}维向量，即n^{[2]}*1</script><ul><li>梯度下降的做法就是用 变量 减去 学习率与对应偏导数的乘积</li></ul><script type="math/tex; mode=display">\begin{array}\\Repeat\{\\dw^{[1]} = \frac{\partial J}{\partial w^{[1]}}, db^{[1]} = \frac{\partial J}{\partial b^{[1]}} …… \\w^{[1]} = w^{[1]} - \alpha * dw^{[1]},b^{[1]} = b^{[1]} - \alpha * db^{[1]},……\\\}\end{array}</script><ul><li><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>具体的过程为（向量化）：</p></li></ul><script type="math/tex; mode=display">\begin{array}dZ^{[2]} = A^{[2]} - Y \\dW^{[2]} = \frac{1}{m}dZ^{[2]} * A^{[1]T} \\db^{[2]} =  \frac{1}{m}np.sum(dZ^{[2]},axis=1,keepdims=True)\\axis=1为水平方向，keepdims=True防止输出秩为一的矩阵即(n,)这种形式 \\dZ^{[1]} = W^{[2]T}  dZ^{[2]} .* g^{[1]'}(Z^{[1]})              \\dW^{[1]} = \frac{1}{m} dZ^{[1]}X^{T}\\db^{[1]} = \frac{1}{m}np.sum(dZ^{[1]},axis=1,keepdims=True)\\\end{array}</script>  <font color="red">（   .* 代表逐个元素相乘  ）</font><p>整个过程就是这样，如果不是很明白，可以去B站搜一搜，有很多推导过程，由于时间所限，这里就不一一推导。</p><h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><p>在逻辑回归中，将权重参数全部初始化为0这是可以的，但是在NN中这是不行的。我们来看一看这是为什么。</p><p><img src="https://i.loli.net/2020/03/31/FcsIWydzCPEST6k.png" style="zoom:50%;"></p><p>在上图中，有两个输入即<script type="math/tex">n^{[0]} =2</script>, 隐藏层有两个单元即<script type="math/tex">n^{[1]} =2</script>,那么<script type="math/tex">W^{[1]}</script>是一个2x2的矩阵，<script type="math/tex">b^{[1]}</script>是一个2x1的矩阵。而这会导致无论输入是什么，总有<script type="math/tex">a^{[1]}_1 =</script> <script type="math/tex">a^{[1]}_2</script>。当进行反向传播的时候，由于对称问题，会导致 <script type="math/tex">dz^{[1]}_1</script> = <script type="math/tex">dz^{[1]}_2</script></p><p>…… </p><p>因此，如果全部初始化为0的话，所以的隐藏单元实际上都是相同的，无论训练多久，它们始终相同。推广到多个隐藏层，隐藏单元也依旧成立。所以需要随机初始化。</p><hr><p>本周内容相对而言稍微难一点，主要是反向传播中的链式求导，不太熟的可以去看看链式求导法则。最好是要搞懂原理，不然在之后的多层网络中会比较难以理解</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>neural-networks-deep-learning-week2</title>
      <link href="/posts/3ee1b592.html"/>
      <url>/posts/3ee1b592.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="/js/baidu.js"></script><script type="text/javascript" src="/js/360.js"></script><h1 id="Deep-Learning-将逻辑回归模型作为神经网络"><a href="#Deep-Learning-将逻辑回归模型作为神经网络" class="headerlink" title="[Deep Learning]将逻辑回归模型作为神经网络"></a>[Deep Learning]将逻辑回归模型作为神经网络</h1><p>最近开始学习吴恩达的deeplearning课程，从第二周开始，会开始介绍关于逻辑回归模型的一些简单定义，在这里开始做一些简单的笔记，用以后面的复习。</p><a id="more"></a><ul><li><h4 id="预测输出"><a href="#预测输出" class="headerlink" title="预测输出"></a>预测输出</h4></li></ul><script type="math/tex; mode=display">  \hat{y} = sigmoid(w^{T} + b)</script><script type="math/tex; mode=display">  sigmoid = \frac{1}{1 + e^{-z}}</script><ul><li><h4 id="损失函数（Loss）："><a href="#损失函数（Loss）：" class="headerlink" title="损失函数（Loss）："></a>损失函数（Loss）：</h4><p>对于线性回归中：</p><script type="math/tex; mode=display">L = \left(\dfrac{1}{2}\right) (\hat{y} - y)^{2}</script><p>而在逻辑回归中，损失函数被定义为：</p><script type="math/tex; mode=display">L = -(ylog(\hat{y}) + (1-y)log(1-\hat{y}))</script><p>具体而言，可以这么理解 yhat：</p><p>即在给定x的情况下 y等于1的概率为多少 </p><script type="math/tex; mode=display">\hat{y} = p(y=1|x)</script></li></ul><p>  也就是说 </p><p>  如果 y=1  </p><script type="math/tex; mode=display">  p(y|x) = \hat{y}</script><p>  如果 y=0</p><script type="math/tex; mode=display">  p(y|x) = 1 - \hat{y}</script><p>  将两种情况写在一起 即为  （将y=0 y=1 代入 可以得到与上面相同的公式）</p><script type="math/tex; mode=display">  p(y|x) = \hat{y}^{y}(1 - \hat{y})^{1 - y}</script><p>  又由于log函数为单调增函数，故取对数</p><script type="math/tex; mode=display">  log\left(p(y|x)\right) = ylog(\hat{y}) + (1-y)log(1-\hat{y}) = -L</script><p>  注意这里的负号，因为在逻辑回归中，我们想最大化概率，所以就需要最小化损失函数。</p><ul><li><h4 id="代价函数（COST）"><a href="#代价函数（COST）" class="headerlink" title="代价函数（COST）"></a>代价函数（COST）</h4><p>在m个样本中的代价可以定义为</p><script type="math/tex; mode=display">log(p) = log\prod_{i=1}^m p(y^\left(i\right)|x^\left(i\right)) = \sum_{i=1}^m log\left(p(y^\left(i\right)|x^\left(i\right))\right) = -\sum_{i=1}^m L(\hat{y}^\left(i\right),y^\left(i\right))</script><p>（在统计学中，有一种最大似然估计的方法，即选择使式子最大化的参数。）</p><p>则有 </p><script type="math/tex; mode=display">J(w,b) =\frac{1}{m}\sum_{i=1}^m  L(\hat{y}^\left(i\right),y^\left(i\right))</script><p>因为这里要求最小值，故不需要这个负号(1/m 为缩放系数，只是为了最后的数值能在更好的尺度上，没有其他特殊含义)</p></li></ul><ul><li><h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><p>在逻辑回归中，我们有以下的定义：</p><p><img src="https://i.loli.net/2020/03/28/P8XJSrQYeNp4ozO.png" alt></p><p>对其求偏导数（链式求导，如果不熟悉，可以看宇哥的十八讲~）</p><script type="math/tex; mode=display">\frac{dL}{da} = -\frac{y}{a} + \frac{1-y}{1-a}</script></li></ul><script type="math/tex; mode=display">  \frac{da}{dz} =-(1+e^{-z})^{-2} * -e^{-z} = e^{-z}*(1+e^{-z})^{-2} = a*(1-a)</script><p>注：</p><script type="math/tex; mode=display">e^{-z}*(1+e^{-z})^{-2} = \frac{e^{-z}}{(1+e^{-z})^{2}} = \frac{1+e^{-z}-1}{(1+e^{-z})^{2}} = \frac{1}{1+e^{-z}} - \frac{1}{(1+e^{-z})^{2}} = a-a^2=a(1-a)</script><p>则有</p><script type="math/tex; mode=display">\frac{dL}{dz} = \frac{dL}{da} * \frac{da}{dz} =(-\frac{y}{a} + \frac{1-y}{1-a}) * a(1-a)=a-y</script><p>同样的</p><script type="math/tex; mode=display">\frac{dL}{dw_1} = x_1*dz</script><p>在计算出这些导数后，就可以进行梯度下降了</p><script type="math/tex; mode=display">w_1 = w_1 - \alpha*dw_1</script><script type="math/tex; mode=display">w_2 = w_2 - \alpha*dw_2</script><script type="math/tex; mode=display">b = b -\alpha*db</script><hr><p>以上就是对第二周的小小整理（没有对向量化的部分以及numpy的使用做总结，关于numpy的使用会单独写），具体来说，这门课和之前的机器学习中讲的略有不同，比如记号之类的地方，但是大体而言还是差不多的，加油加油！</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
